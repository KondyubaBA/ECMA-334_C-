## 9.2 Категории переменных

### 9.2.1 Общие сведения
C# определяет восемь категорий переменных: статические переменные, переменные экземпляра, элементы массива, параметры значения, параметры ввода, параметры ссылки, выходные параметры и локальные переменные. В следующих подпунктах описаны каждая из этих категорий.
Пример: В следующем коде
```csharp
class A
{
  public static int x;
  int y;
  void F(int[] v, int a, ref int b, out int c, in int d)
  {
    int i = 1;
    c = a + b++ + d;
  }
}
```
x — это статическая переменная, y — это переменная экземпляра, v[0] — это элемент массива, a — это параметр значения, b — это параметр ссылки, c — это выходной параметр, d — это входной параметр, а i — это локальная переменная. конец примера

### 9.2.2 Статические переменные
Поле, объявленное с модификатором static, является статической переменной. Статическая переменная появляется до выполнения статического конструктора (§15.12) для своего содержащего типа и перестает существовать, когда связанная с ней область приложения перестает существовать.
Начальное значение статической переменной — это значение по умолчанию (§9.3) для типа переменной.

Для целей проверки определенного присвоения статическая переменная считается изначально присвоенной.

### 9.2.3 Переменные экземпляра
#### 9.2.3.1 Общие сведения
Поле, объявленное без модификатора static, является переменной экземпляра.

#### 9.2.3.2 Переменные экземпляра в классах
Переменная экземпляра класса появляется, когда создается новый экземпляр этого класса, и перестает существовать, когда нет ссылок на этот экземпляр и финализатор экземпляра (если он есть) выполнен.
Начальное значение переменной экземпляра класса — это значение по умолчанию (§9.3) для типа переменной.
Для целей проверки определенного присвоения переменная экземпляра класса считается изначально присвоенной.

#### 9.2.3.3 Переменные экземпляра в структурах
Переменная экземпляра структуры имеет точно такую же продолжительность жизни, как и переменная структуры, к которой она принадлежит. Другими словами, когда переменная типа структуры появляется или перестает существовать, то же происходит и с переменными экземпляра структуры.
Начальное состояние присвоения переменной экземпляра структуры такое же, как и у содержащей переменной структуры. Другими словами, когда переменная структуры считается изначально присвоенной, то же самое относится и к её переменным экземпляра, и когда переменная структуры считается изначально неприсвоенной, её переменные экземпляра также считаются неприсвоенными.

### 9.2.4 Элементы массива
Элементы массива появляются, когда создается экземпляр массива, и перестают существовать, когда нет ссылок на этот экземпляр массива.
Начальное значение каждого из элементов массива — это значение по умолчанию (§9.3) для типа элементов массива.
Для целей проверки определенного присвоения элемент массива считается изначально присвоенным.

### 9.2.5 Параметры значения
Параметр, объявленный без модификатора in, out или ref, является параметром значения.
Параметр значения появляется при вызове члена функции (метода, конструктора экземпляра, аксессора или оператора) или анонимной функции, к которой принадлежит параметр, и инициализируется значением аргумента, переданного при вызове. Параметр значения обычно перестает существовать, когда выполнение тела функции завершается. Однако если параметр значения захвачен анонимной функцией (§12.19.6.2), его продолжительность жизни продлевается как минимум до тех пор, пока делегат или дерево выражений, созданное из этой анонимной функции, не станет доступным для сборки мусора.
Для целей проверки определенного присвоения параметр значения считается изначально присвоенным.

### 9.2.6 Параметры-ссылки
Параметр, объявленный с модификатором ref, является параметром-ссылкой.
Параметр-ссылка является ссылочной переменной (§9.7), которая появляется при вызове члена функции, делегата, анонимной функции или локальной функции, и её ссылаемое значение инициализируется переменной, переданной в качестве аргумента в этом вызове. Параметр-ссылка перестает существовать, когда выполнение тела функции завершается. В отличие от параметров значения, параметр-ссылка не может быть захвачен (§9.7.2.9).

К параметрам-ссылкам применяются следующие правила определенного присвоения:
Примечание: Правила для выходных параметров отличаются и описаны в (§9.2.7). конец примечания

Переменная должна быть определенно присвоена (§9.4) до того, как она может быть передана в качестве параметра-ссылки при вызове члена функции или делегата.
Внутри члена функции или анонимной функции параметр-ссылка считается изначально присвоенным.
Для типа struct внутри метода экземпляра или аксессора экземпляра (§12.2.1) или конструктора экземпляра с инициализатором конструктора ключевое слово this ведет себя точно так же, как параметр-ссылка типа struct (§12.8.13).

### 9.2.7 Выходные параметры
Параметр, объявленный с модификатором out, является выходным параметром.
Выходной параметр является ссылочной переменной (§9.7), которая появляется при вызове члена функции, делегата, анонимной функции или локальной функции, и её ссылаемое значение инициализируется переменной, переданной в качестве аргумента в этом вызове. Выходной параметр перестает существовать, когда выполнение тела функции завершается. В отличие от параметров значения, выходной параметр не может быть захвачен (§9.7.2.9).

К выходным параметрам применяются следующие правила определенного присвоения:
Примечание: Правила для параметров-ссылок отличаются и описаны в (§9.2.6). конец примечания

Переменная не обязательно должна быть определенно присвоена до того, как она может быть передана в качестве выходного параметра при вызове члена функции или делегата.
После нормального завершения вызова члена функции или делегата каждая переменная, которая была передана в качестве выходного параметра, считается присвоенной на этом пути выполнения.
Внутри члена функции или анонимной функции выходной параметр считается изначально неприсвоенным.
Каждый выходной параметр члена функции, анонимной функции или локальной функции должен быть определенно присвоен (§9.4) до того, как член функции, анонимная функция или локальная функция нормально завершит выполнение.

### 9.2.8 Входные параметры
Параметр, объявленный с модификатором in, является входным параметром.
Входной параметр является ссылочной переменной (§9.7), которая появляется при вызове члена функции, делегата, анонимной функции или локальной функции, и её ссылаемое значение инициализируется ссылкой на переменную, переданную в качестве аргумента в этом вызове. Входной параметр перестает существовать, когда выполнение тела функции завершается. В отличие от параметров значения, входной параметр не может быть захвачен (§9.7.2.9).

К входным параметрам применяются следующие правила определенного присвоения:

Переменная должна быть определенно присвоена (§9.4) до того, как она может быть передана в качестве входного параметра при вызове члена функции или делегата.
Внутри члена функции, анонимной функции или локальной функции входной параметр считается изначально присвоенным.

### 9.2.9 Локальные переменные
Локальная переменная объявляется с помощью local_variable_declaration, declaration_expression, foreach_statement или specific_catch_clause оператора try_statement. Локальная переменная также может быть объявлена некоторыми видами шаблонов (§11). Для foreach_statement локальная переменная является переменной итерации (§13.9.5). Для specific_catch_clause локальная переменная является переменной исключения (§13.11). Локальная переменная, объявленная с помощью foreach_statement или specific_catch_clause, считается изначально назначенной.

local_variable_declaration может появляться в блоке, операторе for_statement, switch_block или using_statement. declaration_expression может появляться как аргумент out и как tuple_element, который является целью деконструирующего присваивания (§12.21.2).

Срок жизни локальной переменной — это часть выполнения программы, в течение которой гарантируется выделение памяти для нее. Этот срок жизни начинается с входа в область видимости, с которой она связана, и продолжается, по крайней мере, до завершения выполнения этой области видимости. (Вход в вложенный блок, вызов метода или возврат значения из блока-итератора приостанавливает, но не завершает выполнение текущей области видимости.) Если локальная переменная захватывается анонимной функцией (§12.19.6.2), срок ее жизни продолжается как минимум до тех пор, пока делегат или дерево выражений, созданное из анонимной функции, вместе с другими объектами, которые ссылаются на захваченную переменную, не будут доступны для сборки мусора. Если родительская область видимости входится рекурсивно или итеративно, каждый раз создается новый экземпляр локальной переменной, и ее инициализатор (если таковой имеется) оценивается каждый раз.

Примечание: Локальная переменная создается каждый раз, когда ее область видимости входит. Это поведение видно для пользовательского кода, содержащего анонимные методы. Конец примечания.

Примечание: Срок жизни переменной итерации (§13.9.5), объявленной foreach_statement, составляет одну итерацию этого оператора. Каждая итерация создает новую переменную. Конец примечания.

Примечание: Реальный срок жизни локальной переменной зависит от реализации. Например, компилятор может статически определить, что локальная переменная в блоке используется только для небольшой части этого блока. Используя этот анализ, компилятор может сгенерировать код, который приведет к тому, что срок жизни переменной будет короче, чем срок жизни блока, содержащего ее.

Память, на которую ссылается локальная переменная-ссылка, освобождается независимо от срока жизни этой локальной переменной-ссылки (§7.9). Конец примечания.

Локальная переменная, введенная с помощью local_variable_declaration или declaration_expression, не инициализируется автоматически, и поэтому не имеет значения по умолчанию. Такая локальная переменная считается изначально не назначенной.

Примечание: Локальная переменная с инициализатором по-прежнему считается изначально не назначенной. Выполнение объявления ведет себя точно так же, как присваивание переменной (§9.4.4.5). Использование переменной до того, как был выполнен ее инициализатор, например, в самом выражении инициализатора или при использовании оператора goto_statement, который обходит инициализатор, является ошибкой времени компиляции:
```chsarp
goto L;
int x = 1; // никогда не выполнится
L: x += 1; // ошибка: x не определен
```
В пределах области видимости локальной переменной является ошибкой времени компиляции ссылка на эту локальную переменную в текстовом положении, предшествующем ее объявлению. Конец примечания.

#### 9.2.9.1 Отклонения
Отклонение — это локальная переменная, у которой нет имени. Отклонение вводится выражением объявления (§12.17) с идентификатором _ и может быть либо неявно типизированным (_ или var _), либо явно типизированным (T _).

Примечание: _ является допустимым идентификатором во многих формах объявлений. Конец примечания.

Поскольку у отклонения нет имени, единственная ссылка на переменную, которую оно представляет, — это выражение, которое вводит его.

Примечание: Однако отклонение может быть передано как аргумент out, позволяя параметру out обозначать соответствующее ему местоположение памяти. Конец примечания.

Отклонение изначально не назначено, поэтому всегда является ошибкой доступ к его значению.

Пример:
```csharp
_ = "Hello".Length;
(int, int, int) M(out int i1, out int i2, out int i3) { ... }
(int _, var _, _) = M(out int _, out var _, out _);
```

В примере предполагается, что имя _ нигде не объявлено в области видимости.

Присваивание _ демонстрирует простой шаблон для игнорирования результата выражения. Вызов M показывает различные формы отклонений, доступные в кортежах и как параметры out. Конец примера.
